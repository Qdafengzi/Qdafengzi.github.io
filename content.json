{"meta":{"title":"Qdafengzi","subtitle":null,"description":null,"author":"Qdafengzi","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"02_Kotlin基础知识","slug":"02.Kotlin基础知识","date":"2017-11-20T14:32:53.000Z","updated":"2017-11-20T16:31:48.645Z","comments":true,"path":"2017/11/20/02.Kotlin基础知识/","link":"","permalink":"http://yoursite.com/2017/11/20/02.Kotlin基础知识/","excerpt":"","text":"Kotlin基础知识1.定义变量和常量​ 变量var var n:Int = 30 var ok:Int var abc = 124 var s = “abc” 常量val val m:Int = 124 位置不同：在Kotlin中数据类型放到变量后面，并用:分割 变量用var 常量用val Kotlin内置类型首字母都是大写的 Kotlin可以根据右侧初始化的值自动推导数据类型，初始化可以不写数据类型 2.定义函数​ 函数头，主要包括函数名和标识函数的关键字 参数，包括参数名和参数类型 返回值，包括返回值的类型，如果没有返回值 有返回值 fun add(m:Int,n:Int):Int{ return m + n } 无返回值 fun process(m:Int):Unit{ println(m) } 无返回值 fun process(m:Int){ println(m) } 3.注释 和Java区别是多行注释可以嵌套 4.数据类型​ 数据类型 占用字节数 Double 8 Float 4 Long 8 Int 4 Short 2 Byte 1 不能像Java一样自动转换 要用toByte toShort toInt等方法 表示Long，数值后面加l或L，123L 表示Float，数值后面加f或F，123.3F 目前Kotlin只支持十六进制和二进制 十六进制用0x开头，0x1E 二进制：数值用0b开头，0b10011 下划线_分隔符把数值分开 val oneMillion = 1_000_000 5.字符类型​ Char表示 如果c和97比较必须c.toInt之后才可以比较 6.布尔类型​ Boolean7.数组​ arrayOf可以存储任何值的数组 val arr = arrayOf(1,2,3,’a’,”adsa”,true) 超过范围就会索引越界和Java一样 arrayOfNulls直接定义一个长度为10的整型数组 val arr1 = arrayOfNulls&lt;Int&gt;(10) 没初始化默认为null，因为是对象 使用Array类构造数组长度和初始化数据方法 var arr3 = Array(10,{i -&gt; (i*i).toString()}) intArrayOf、shortArrayOf等 var arr4: IntArray = intArrayOf(10,20,30) 8.字符串 普通字符串和Java一样 保留原始格式的字符串(raw string) var s1 = &quot;&quot;&quot; hello world 时间 “”“ 字符串模版（占位符） val i = 10 val s2 = &quot;i = $i&quot; 9.包(Package) Java 包与目录有关 Test.java package a.b; Kotlin 与当前目录无关 他可以给包取别名 import baidu.com.MyClass as my 10.条件语句when​ 类似Java的switch x = 1 when(x){ 1-&gt;{ println(“1—-“) } 2-&gt;{ println(&quot;2-----&quot;) } else{ println(&quot;其他&quot;) } } 如果是对应的多个值 var y = 1 when(y){ 1,2,3,4,5-&gt;{ println(&quot;以下符合条件&quot;) } 10-&gt;{ println(&quot;以下不符合条件&quot;) } else{ println(&quot;其他&quot;) } } when作为表达式使用 var xyz = 1 var m = when(xyz){ 1-&gt;{ println(&quot;xyz==1&quot;) 20 } 2-&gt;{ println(&quot;xyz==2&quot;) 40 } else{ 100 } } 使用in关键字 var n = 20 when(n){ in 1..15-&gt;print(&quot;满足条件&quot;) in 16..20-&gt;println(“不满足条件”) !in 100..200-&gt;println(&quot;hello world&quot;) else-&gt;println(&quot;条件未知&quot;) } 分支条件是一个函数 fun double(x:Int):Int{ return x * x } var ok = 9 when(ok){ double(2)-&gt;println(&quot;不满足条件&quot;) double(3)-&gt;println(&quot;满足条件&quot;) else-&gt;println(&quot;条件未知&quot;) } 11.循环语句中的for​ var arr = intArrayOf(1,2,3,4,5) for(item: Int in arr){ println(item) } for(i in arr.indices){ println(&quot;arr[$i] = &quot; + arr[i]) } for((index, value) in arr.withIndex()){ println(&quot;arr[$index] = &quot; + value) } 12.循环语句while var i = 0 while(i++ &lt; 10){ println(i) } do{ if(i==8){ continue } println(i) if(i == 6){ break } }while(--i &gt; 0)","categories":[],"tags":[]},{"title":"01_Kotlin类和接口","slug":"03.类和接口","date":"2017-11-20T14:32:53.000Z","updated":"2017-11-20T16:32:10.964Z","comments":true,"path":"2017/11/20/03.类和接口/","link":"","permalink":"http://yoursite.com/2017/11/20/03.类和接口/","excerpt":"","text":"类和接口1.类的声明 class MyClass{} 2.构造器 主构造器 声明的时候在类的后面(可以省略constructor) class Person constructor(name:String){ //初始化 init{ println(name) } } fun main(args: Array&lt;String&gt;){ var person = Person(&quot;Tony&quot;) } 次构造器 class Product{ constructor(parent:Product){ println(parent) } } class QACommunity(var url:String){ //主构造器的实现部分 init{ println(url) } //次构造器，可以有多个 //通过this直接调用了主构造器 constructor(value:Int):this(&quot;www.baidu.com&quot;) println(value) //通过调用其他次构造器间接调用了主构造器 constructor():this(20){ prontln(&quot;通过调用其他次构造器间接调用了主构造器&quot;) } } 注意： 如果类定义类主构造器，次构造器必须直接或者间接的调用 如果类未定义主构造器，次构造器不用调用 ​ ​​​​​​​","categories":[],"tags":[]},{"title":"01_Linux基础命令","slug":"Linux","date":"2017-11-20T14:32:53.000Z","updated":"2017-11-20T16:33:06.811Z","comments":true,"path":"2017/11/20/Linux/","link":"","permalink":"http://yoursite.com/2017/11/20/Linux/","excerpt":"","text":"基础命令一、命令(最基础)1.进入图形界面：startX 2.shutdown -h now 立刻进行关机 3.shutdown -r now 现在重启 / reboot 4.当前在那个目录pwd 5.添加用户 useradd xiaoming 6.设置密码 passwd xiaoming 7.删除用户 userdel xiaoming 8.删除用户及用户主目录 userdel -r xiaoming 二、常用命令 级别： 0.0用户级别：关机 ​ 1.单用户模式 2.多用户没有网络状态 3.多用户网络状态(常用) 4.系统未使用保留给用户 5.图形化界面 6.系统重启 命令 ls -a显示隐藏文件 ​ ls -l显示长列表格式 ls -al ls -ld 文件夹 显示文件目录的信息，而不是文件下的文件列表 ls -lh显示文件的详情，文件大小人性化显示 mkdir 建立目录 rmdir 删除目录 grep &quot;关键词&quot; 文件名 查看文件中是否有此关键词 find / -name 文件名字 从根目录查找文件 ls -l &gt; a.txt列表的内容写入文件a.txt中(覆盖) ls -i文件目录i界面，一个文件的唯一标识 ls -al &gt;&gt; aa.txt列表的内容追加到文件aa.txt的末尾 groupadd policeman添加警察组 useradd -g policeman xiaoming 把小明添加到policeman组里面 chmod 777 tony 赋予tony权限 logout 切换用户 cat 文件 查看文件 vi 文件 不仅可以查看还可以修改 ​ -rwxrw-r-- ​ -(文件类型 -二进制文件d目录 l软链接文件) rwx(文件所有者的权限) rw-(与文件所有者同一组的用户权限) r--(不与文件所有者同组的其他用户的权限) - 代表文件类型(-文件d目录l链接)，r可读用4表示，w可写用2表示，x可执行 用1表示 ​ 三、命令mkdir Japan 创建Japan目录 mkdir -p Japan/xiaodingying 递归创建目录 mkdir -p Japan/cangjing Japan/longze 递归创建多个目录 cd 切换目录 change directory pwd 显示当前目录 print working directory cd ..回到上一层目录 rmdir 删除一个空目录 remove empty directories cp + 文件目录 + 要复制的文件目录 cp -rp[源文件或目录][目标目录] cp -r 复制目录 cp -p 保留文件属性 Ctrl + l 清屏 mv + 源文件或目录 + 目标目录 剪切处理 rm + 源文件或目录 + 目标目录 删除处理 rm -rf 删除一个目录 -r删除目录 -f强制执行 Ctrl + c 终止操作 touch +文件名 创建文件 cat 文件名 查看文件内容 cat -n 文件名 查看文件并带有行号 tac 文件名 倒序显示内容 more 文件名字 分页查看 f 翻页 Enter 换行 q或者Q退出 less 文件名字 Enter 换行 上箭头 空格 翻页 /关键词 搜索 按n进行查看所有的关键词(n代表next) head -n 7 显示文件的前7行 不加-n 默认是前十行 tail 文件名 显示文件的后面几行 -n 指定行数 -f 动态显示文件末尾的内容 ln -s + 原文件 + 目标文件 软链接 lrwxrwxrwx l软链接，会显示文件指向 四、权限管理chmod [{ugoa}{+-=}{rwx}][文件或目录] chmod [mode=421] [文件或目录] chmod -R 递归修改 r --- 4 w --- 2 x --- 1 rwxrw-r-- 7 6 4 File​ r:cat/more/head/tail/less w:vim x:script command Directory​ r:ls w:touch/mkdir/rmdir/rm x:cd chown change file ownership chown + 用户名 + 文件或目录改变一个文件的所有者 chgrp change file group chgrp 用户组 + 文件或目录 umask [-S]以rwx形式显示新建文件缺省权限 五、搜索find [搜索范围][匹配条件] find + 目录 -name init 搜索目录文件夹中init的文件 find + 目录 -name * init * 搜索目录文件夹中文件名包含init的文件 find + 目录 -iname init 搜索目录文件夹中init的文件（不区分大小写） find + 目录 -size +204800 搜索目录文件夹中大于100M的文件 find /ect -size +163840 -a -size -204800查找文件中大于80M小于100M的文件 一个数据块 512字节 0.5k find /home -user + 所属组 查看所属组下的文件 find /etc -cmin -5查找5分钟内被修改过属性的文件和目录 -amin 访问时间access -cmin 文件属性 change -mmin 文件内容 modify -type添加后可以指定查找的文件类型，f文件 d目录 l软链接文件 -a 两个条件都满足 -o 两个条件满足其一即可 find /etc -name inittab -exec ls -l{}\\; 在/etc下查找inittab文件并显示其详细信息 find /etc -inum 31551 -exec rm {}\\; 在目录下找到31551节点的文件并且删除 locate + 文件名已有的文件(临时创建的查找不到，临时文件也会查找不到) updatedb升级文件资料库(升级之后临时文件还是查找不到) which + 命令的名字 查找命令的所在位置 whereis + 命令的名字 查找命令的绝对位置 grep + 关键词 + 文件所在的路径 查找关键词所在文件中的情况 grep -i + 关键词 + 文件所在的路径 查找关键词所在文件中的情况（不区分大小写） grep -v ^# + 文件所在的路径 查找关键词所在文件中的情况(去掉注释内容的文件内容) ​ ​​","categories":[],"tags":[]},{"title":"01_Kotlin引入","slug":"01.Kotlin引入","date":"2017-11-20T14:32:53.000Z","updated":"2017-11-20T16:31:21.090Z","comments":true,"path":"2017/11/20/01.Kotlin引入/","link":"","permalink":"http://yoursite.com/2017/11/20/01.Kotlin引入/","excerpt":"","text":"Kotlin引入1.在线运行环境：​ https://try.kotlinlang.org 2.安装运行环境并配置​ https://github.com/JetBrains/kotlin/releases/tag/v1.1.50 3.REPL环境 read-eval-print loop交互式解释环境 所有的命令都是以:开头 4.在命令行运行脚本文件​ 文件扩展名为.kts kotlinc -script test.kts5.在浏览器中运行Kotlin程序​6.如何在Node.js中运行Kotlin程序​ 转换为JavaScript后用7.在微信小程序中运行Kotlin程序​ 现在最大的小程序包不能超过3M8.Kotlin语法糖​ JVM（byte code）","categories":[],"tags":[]},{"title":"Python基础教程","slug":"python基础教程","date":"2017-11-20T14:32:53.000Z","updated":"2017-11-20T16:33:36.554Z","comments":true,"path":"2017/11/20/python基础教程/","link":"","permalink":"http://yoursite.com/2017/11/20/python基础教程/","excerpt":"","text":"1.安装测试​ 安装略···· 检测：终端输入python 退出Ctrl - D 或者 exit() python2 和 Python3的区别是前者不支持中文，后者支持和中文 2.字符编码 123456ASCII 255 1bytes1980 gb2312 7000多个字符1995 GBK1.0 2w+2000 GB18030 27000多个Unicode 2bytesutf-8 en:1byte,zh:3bytes 3.注释 12单行注释 #多行注释 &apos;&apos;&apos;&apos;&apos;&apos;注释内容&apos;&apos;&apos;&apos;&apos;&apos; 4.输入输出 123input print 5.密码输入时密文 1引入：import getpass 6.缩进错误 1IndentationError: 7.sys模块 12sys.path #环境变量sys.argv #相对路径 8.os模块 12cmd_res = os.system(&quot;dir&quot;) #执行命令不保存结果cmd_res = os.popen(&quot;dir&quot;).read() #执行命令保存结果并输出 9.bytes数据类型 Python3中在网络中的数据传输都必须用二进制数据进行 123&apos;￥20&apos;.encode(&apos;utf-8&apos;)b&apos;\\xef\\xbf\\xa520&apos;.decode(&apos;utf-8&apos;) 10.列表 123456789101112131415161718list = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos; e&apos;]print(list[1:3]) # 取值 b cprint(list[-1]) #可以取负索引值print(list[:3]) #取值相当于[0:3]print(list[-2:-1]) #取值相当于[-2:-1]list.append(&apos;x&apos;) #拼接list.insert(1,&apos;y&apos;) #插入list.remove(&apos;b&apos;) #删除del list[1] #删除list.pop() #没有下标就默认删除最后一个list.index(&apos;a&apos;) #输出下标值 list.count(&apos;a&apos;) #输出a的个数list.reverse() #反转list.sort() #排序 ASCII码的排序规则list2 = [&apos;n&apos;,&apos;m&apos;] list.extend(lists) #拼接list2 11.copy 12345678copy.copy() #浅copy，如果一个列表中的某个元素是一个列表，修改这个列表的元素值，结果不是自己想要的copy.deepcopy() #深copy实现浅copy的方法person = [&apos;a&apos;, &apos;b&apos;, [&apos;n&apos;, &apos;m&apos;], &apos;x&apos;]p1 = copy.copy(person)p2 = person[:]p3 = list(person) 123456789101112131415161718import copynames = [&apos;a&apos;, &apos;b&apos;, [&apos;n&apos;, &apos;m&apos;], &apos;x&apos;]names2 = copy.copy(names)print(names)print(names2)names[1] = &apos;x&apos;names[2][0] = &apos;Tony&apos;print(names)print(names2)#结果[&apos;a&apos;, &apos;b&apos;, [&apos;n&apos;, &apos;m&apos;], &apos;x&apos;][&apos;a&apos;, &apos;b&apos;, [&apos;n&apos;, &apos;m&apos;], &apos;x&apos;][&apos;a&apos;, &apos;x&apos;, [&apos;Tony&apos;, &apos;m&apos;], &apos;x&apos;][&apos;a&apos;, &apos;b&apos;, [&apos;Tony&apos;, &apos;m&apos;], &apos;x&apos;] 123456789101112131415161718import copynames = [&apos;a&apos;, &apos;b&apos;, [&apos;n&apos;, &apos;m&apos;], &apos;x&apos;]names2 = copy.deepcopy(names)print(names)print(names2)names[1] = &apos;x&apos;names[2][0] = &apos;Tony&apos;print(names)print(names2)#结果[&apos;a&apos;, &apos;b&apos;, [&apos;n&apos;, &apos;m&apos;], &apos;x&apos;][&apos;a&apos;, &apos;b&apos;, [&apos;n&apos;, &apos;m&apos;], &apos;x&apos;][&apos;a&apos;, &apos;x&apos;, [&apos;Tony&apos;, &apos;m&apos;], &apos;x&apos;][&apos;a&apos;, &apos;b&apos;, [&apos;n&apos;, &apos;m&apos;], &apos;x&apos;] 12.元组 又叫只读列表，和列表一样，就是只有count和index方法 1names = (&apos;x&apos;,&apos;y&apos;,&apos;z&apos;) #用小括号表示 13.isdigit、enumerate 123456789Salary = input(&quot;input your salary:&quot;)If salary.isdigit(): #判断是否是数字names = (&apos;x&apos;,&apos;y&apos;,&apos;z&apos;)for index,item in enumerate(name): #enumerate()获取下标 print(index,item) 14.字符串常用操作 123strip去空格相关join数组的拼接maketrans可以做加密 15.集合 1234567891011取交集intersection &amp;list1.intersection(list2)并集 union |差集 difference -子集 issubset父集 issuperset对称差集 symmetric_difference ^isdisjoint是否有交集pop 删除remove 删除不存在的会出错discard 删除不存在的不会报错 16.文件的操作 1234567891011open(&quot;文件&quot;).read();open(&quot;yest&quot;,&apos;r&apos;,encoding); &apos;r&apos;读 &apos;w&apos;写 &apos;a&apos;读和写append &apos;r+&apos;读写(不常用) &apos;w+&apos;读写(读和追加)&apos;rb&apos;、&apos;wb&apos;二进制的处理(不用写enconding否则报错) readlines() #读取一行，小文件f = open(&quot;yesterday&quot;,&apos;r&apos;, enconding = &apos;utf-8&apos;)f.tell() #光标的位置f.seek(0) #回到0f.enconding #编码f.seekable(self) #是否光标可移动f.truncate(20) #截断多少个字符 进度条flush的运用 123456import sys, timefor i in range(30):sys.stdout.write(&apos;#&apos;)sys.stdout.flush()time.sleep(0.2) 1with open() ad f: 用with可以自动关闭 17.字符编码 1gbk——&gt;utf-8 要先转成unicode 18.函数 123456函数没有定义return任何数据的时候会返回None*args接收N个位置参数转换为元组**kwargs代表传递的参数是字典格式的，键值对，个数也是不固定在函数内修改全局变量要用global（字符串和数字） 19.装饰器(重点较难) 12345678910原则： 不能修改被装饰的函数的源代码 不能修改被装饰的函数的调用方式实现： 函数即“变量” 定义之后就才可以使用 高阶函数 把一个函数名当作实参传给另外一个函数 返回值中包含函数名字 嵌套函数 20.列表生成式","categories":[],"tags":[]},{"title":"安卓知识回顾","slug":"安卓知识回顾","date":"2017-11-20T14:32:53.000Z","updated":"2017-11-20T16:32:30.517Z","comments":true,"path":"2017/11/20/安卓知识回顾/","link":"","permalink":"http://yoursite.com/2017/11/20/安卓知识回顾/","excerpt":"","text":"1.获取版本信息 public static String getVersionName(Context context) { String versionName; // 获取包管理器 PackageManager packageManager = context.getPackageManager(); try { PackageInfo packageInfo = packageManager.getPackageInfo(context.getPackageName(), 0); versionName = packageInfo.versionName; } catch (NameNotFoundException e) { versionName = &quot;获取版本信息错误&quot;; e.printStackTrace(); } return versionName; } 2.获取服务器版本信息 class GetServerVisionRunnable implements Runnable { @Override public void run() { InputStream is = null; BufferedReader br = null; try { // 创建连接 HttpURLConnection connection = (HttpURLConnection) new URL( &quot;http://192.168.129.102:8080/version.json&quot;).openConnection(); // 设置连接超时时间 connection.setConnectTimeout(5000); // 设置读取超时时间 connection.setReadTimeout(5000); // 连接 connection.connect(); String result = &quot;&quot;; if (connection.getResponseCode() == 200) { is = connection.getInputStream(); br = new BufferedReader(new InputStreamReader(is)); String readlline; while ((readlline = br.readLine()) != null) { result += readlline; } JSONObject json = new JSONObject(result); int serverVersionCode = json.optInt(&quot;versioncode&quot;); } } catch (Exception e) { e.printStackTrace(); } finally { CommonUtils.CloseStream(is); CommonUtils.CloseStream(br); } } } 3.下载、安装apk class DownloadRunnable implements Runnable { private InputStream inputStream; private FileOutputStream fos; private ProgressDialog pd; public DownloadRunnable(ProgressDialog pd) { this.pd = pd; } @Override public void run() { try { // 初始化 HttpURLConnection connection = (HttpURLConnection) new URL(downUrl).openConnection(); connection.setConnectTimeout(5000); connection.setReadTimeout(5000); connection.connect(); // 连接成功 if (connection.getResponseCode() == 200) { // 创建文件 File file = new File(Environment.getExternalStorageDirectory(), &quot;test.apk&quot;); inputStream = connection.getInputStream(); // 获取文件总长度 int totalLength = connection.getContentLength(); // 设置进度条的总大小 pd.setMax(totalLength); fos = new FileOutputStream(file); int len; byte[] buffer = new byte[1024]; int current = 0; while ((len = inputStream.read(buffer)) != -1) { fos.write(buffer, 0, len); current += len; // 设置进度条的进度 pd.setProgress(current); } // 隐藏进度条 pd.dismiss(); // 安装应用 Intent intent = new Intent(); intent.setAction(&quot;android.intent.action.VIEW&quot;); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.addCategory(&quot;android.intent.category.DEFAULT&quot;); intent.setDataAndType(Uri.parse(&quot;file:&quot; + file.getAbsolutePath()), &quot;application/vnd.android.package-archive&quot;); startActivityForResult(intent, REQ_CODE_INSTALL_APP); } } catch (Exception e) { e.printStackTrace(); } finally { CommonUtils.CloseStream(inputStream); CommonUtils.CloseStream(fos); } } } 4.动画 //沿Y轴旋转的属性动画 ObjectAnimator animator = ObjectAnimator.ofFloat(iv_icon, &quot;rotationY&quot;, 0, 45, 90, 135, 180, 225, 270, 315, 360); // 时常 animator.setDuration(2000); // 重复次数 animator.setRepeatCount(ObjectAnimator.INFINITE); // 重复模式 animator.setRepeatMode(ObjectAnimator.REVERSE); animator.start(); 5.按钮按压效果选择器 在res/drawable/目录下新建一个正常状态下的shape 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;oval&quot; &gt; &lt;!-- oval: 椭圆 --&gt; &lt;!-- 半径 --&gt; &lt;corners android:radius=&quot;16dp&quot; /&gt; &lt;!-- 宽高 --&gt; &lt;size android:height=&quot;32dp&quot; android:width=&quot;32dp&quot; /&gt; &lt;!-- 背景色 --&gt; &lt;solid android:color=&quot;#99ffffff&quot; /&gt; &lt;/shape&gt; 在res/drawable/目录下新建一个按压状态下的shape 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;oval&quot; &gt; &lt;!-- 半径 --&gt; &lt;corners android:radius=&quot;16dp&quot; /&gt; &lt;!-- 宽高 --&gt; &lt;size android:height=&quot;32dp&quot; android:width=&quot;32dp&quot; /&gt; &lt;!-- 背景色 --&gt; &lt;solid android:color=&quot;#33ffffff&quot; /&gt; &lt;/shape&gt; 在res/drawable/目录下新建一个selector 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:enterFadeDuration=&quot;300&quot; android:exitFadeDuration=&quot;300&quot;&gt; &lt;!-- 按压状态使用的背景图 --&gt; &lt;item android:drawable=&quot;@drawable/setting_pressed&quot; android:state_pressed=&quot;true&quot;/&gt; &lt;!-- 默认状态使用的背景图 --&gt; &lt;item android:drawable=&quot;@drawable/setting_normal&quot;/&gt; &lt;!-- 代码执行的时候会从上向下匹配背景图,一旦有一行执行了,下面的就不会再执行.所以一定要将按压状态的背景图放在默认状态的背景图上方,否则背景图永远都是默认状态的 --&gt; &lt;/selector&gt; 为setting按钮设置 android:background属性,值为新建的selector 6.自定义属性 声明自定义属性，参考sdk/platforms/res/values/attrs &lt;attr name=&quot;sivText&quot; format=&quot;reference|string&quot; /&gt; &lt;/declare-styleable&gt; 布局文件使用自定义属性 添加命名空间 xmlns:baidu=&quot;http://schemas.android.com/apk/res/com.baidu.demo&quot; 使用 &lt;com.baidu.demo.view.SettingItemView android:layout_width=&quot;match_parent&quot; baidu:siv_text=&quot;设置1&quot; android:layout_height=&quot;wrap_content&quot;/&gt; 接收属性值 TypedArray ta = context.obtainStyledAttributes(set, R.styleable.SettingItemView); //获取属性值 String sivText = ta.getString(R.styleable.SettingItemView_siv_text); //赋值 mTvSettingItem = (TextView) findViewById(R.id.tv_setting_item); mTvSettingItem.setText(sivText); 7.自定义其他属性 设置item背景的自定义属性：枚举类型，参考TextView ellipsize属性 12345&lt;attr name=&quot;sivBackground&quot;&gt; &lt;enum name=&quot;start&quot; value=&quot;0&quot; /&gt; &lt;enum name=&quot;middle&quot; value=&quot;1&quot; /&gt; &lt;enum name=&quot;end&quot; value=&quot;2&quot; /&gt; &lt;/attr&gt; 获取枚举类型属性：参考TextView源码读取ellipsize属性，a.getInt() 1int sivBackground = ta.getInt(R.styleable.SettingItemView_sivBackground,SETTING_ITEM_BACKGROUND_START); 自定义控件什么常量，对应枚举的value值 123private final static int SETTING_ITEM_BACKGROUND_START = 0;private final static int SETTING_ITEM_BACKGROUND_MIDDLE = 1;private final static int SETTING_ITEM_BACKGROUND_END = 2; 赋值 switch (sivBackground) { case SETTING_ITEM_BACKGROUND_START: mRlItemView.setBackgroundResource(R.drawable.setting_item_first_selector); break; case SETTING_ITEM_BACKGROUND_MIDDLE: mRlItemView.setBackgroundResource(R.drawable.setting_item_middle_selector); break; case SETTING_ITEM_BACKGROUND_END: mRlItemView.setBackgroundResource(R.drawable.setting_item_last_selector); break; } 8.自定义Dialog 123456789101112131415AlertDialog.Builder builder = new AlertDialog.Builder(this);//填充自定义布局 View view = View.inflate(this, R.layout.activity_setting_setting_pwd, null); final EditText etPwd = (EditText) view.findViewById(R.id.et_pwd); final EditText etComfirmPwd = (EditText) view.findViewById(R.id.et_comfirm_pwd); Button btnOk = (Button) view.findViewById(R.id.btn_ok); Button btnCancel = (Button) view.findViewById(R.id.btn_cancel); builder.setView(view); final AlertDialog dialog = builder.show(); 9.Activity界面间的跳转动画（需要在基类中设置Activity进出的动画） 1234567891011121314151617181920212223242526272829303132333435363738394041设置Activity跳转：公共style中添加onClick方法（clickNext、clickPre）,对应Activity实现方法在res文件夹下建立anim文件夹，再建立XML文件如下：next_step_enter.xml、next_step_exit.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;200&quot; android:fromXDelta=&quot;100%p&quot; android:toXDelta=&quot;0&quot;/&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;200&quot; android:fromXDelta=&quot;-100%p&quot; android:toXDelta=&quot;0&quot;/&gt;&lt;!-- 下一步 --&gt;&lt;style name=&quot;btnNextStep&quot; parent=&quot;@style/btnOkNarmal&quot;&gt; &lt;item name=&quot;android:drawableRight&quot;&gt;@drawable/next&lt;/item&gt; &lt;item name=&quot;android:onClick&quot;&gt;clickNextStep&lt;/item&gt;&lt;/style&gt;&lt;!-- 上一步 --&gt;&lt;style name=&quot;btnPreStep&quot; parent=&quot;@style/btnOkNarmal&quot;&gt; &lt;item name=&quot;android:drawableRight&quot;&gt;@drawable/pre&lt;/item&gt; &lt;item name=&quot;android:onClick&quot;&gt;clickPreStep&lt;/item&gt;&lt;/style&gt; //点击事件的触发 public void clickNextStep(View v)&#123; Intent intent = new Intent(this, MainActivity.class); startActivity(intent); overridePendingTransition(R.anim.next_enter_anim, R.anim.next_exit_anim); finish();&#125;public void clickPreStep(View v) &#123; Intent intent = new Intent(this, MainActivity2.class); startActivity(intent); overridePendingTransition(R.anim.pre_enter_anim, R.anim.pre_exit_anim); finish();&#125; 10.手势识别器滑动效果的实现 //手势识别器 GestureDetector mDetector = new GestureDetector(this, new GestureDetector.SimpleOnGestureListener(){ /**手势滑动e1：起点、e2：终点、velocityX：X轴速率、velocityY：Y轴速率*/ @Override public boolean onFling(MotionEvent e1, MotionEvent e2,float velocityX, float velocityY) { float x1 = e1.getRawX(); float x2 = e2.getRawX(); float y1 = e1.getRawY(); float y2 = e2.getRawY(); //速率判断 if(Math.abs(velocityX) &lt; 200){ Log.d(TAG, &quot;速率低&quot;); return true; } //垂直方向判断 if(Math.abs(y2-y1) &gt; Math.abs(x2-x1)){ Log.d(TAG, &quot;垂直方向&quot;); return true; } if(x1 &gt; x2){//向左滑动：下一步，x1&gt;x2 doNext(); LogUtils.d(&quot;下一步&quot;); }else{//向右滑动：上一步，x1&lt;x2 doPre(); LogUtils.d(&quot;上一步&quot;); } Log.d(TAG, &quot;x2-x1=&quot;+(x2-x1)); return super.onFling(e1, e2, velocityX, velocityY); } }); @Override public boolean onTouchEvent(MotionEvent event) { //必须调用手势监听 mDetector.onTouchEvent(event); return super.onTouchEvent(event); } 11.获取手机sim卡信息 123456789//获取sim卡信息 private String getSim()&#123; TelephonyManager manager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE); manager.getLine1Number();//手机号，运营商出厂sim卡，有时候把手机号烧到sim卡上，有时候不烧，不一定，可能为空 return manager.getSimSerialNumber();//不为空，唯一 &#125; //权限6.0以上要动态申请权限&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt; 12.手机联系人 内容解析者：ContentResolver 需求：一个联系人可能有多个号码，比如有2个，就有2个item，对应2个联系人 Uri uri = ContactsContract.CommonDataKinds.Phone.CONTENT_URI 名称：ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME 号码：ContactsContract.CommonDataKinds.Phone.NUMBER 联系人id：ContactsContract.CommonDataKinds.Phone.CONTACT_ID 1234567891011121314151617181920ContentResolver resolver = context.getContentResolver(); Uri uri = ContactsContract.CommonDataKinds.Phone.CONTENT_URI; String[] projection = new String[]&#123;ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME, ContactsContract.CommonDataKinds.Phone.NUMBER, ContactsContract.CommonDataKinds.Phone.CONTACT_ID&#125;; //查询内容 String selection = null; //查询条件 String[] selectionArgs = null;//查询条件对应参数 String sortOrder = ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME+&quot; desc&quot;; //排序 Cursor cursor = resolver.query(uri, projection, selection, selectionArgs, sortOrder); if(cursor != null)&#123; while(cursor.moveToNext())&#123; Contact contact = new Contact(); contact.name = cursor.getString(0); contact.number = cursor.getString(1); contact.id = cursor.getLong(2); list.add(contact); &#125; cursor.close(); &#125; return list; ​ 通过id获取联系人头像 单独封装一个方法，通过id获取头像bitmap ContactsContract：联系人协议 content://contacts 所有联系人uri，content://contacts/id 指定联系人id的uri ContentResolver cr = context.getContentResolver(); 12345// content://contacts/id 对应id联系人uriUri contactUri = Uri.withAppendedPath(ContactsContract.Contacts.CONTENT_URI, String.valueOf(contactId));InputStream stream = ContactsContract.Contacts.openContactPhotoInputStream(cr, contactUri );return BitmapFactory.decodeStream(stream); 13.监控手机卡的变化 创建广播接收者监听sim卡变化 清单文件注册上述广播 123456&lt;receiver android:name=&quot;com.baidu.BootCompleteReceive&quot; &gt; &lt;intent-filter android:priority=&quot;1000&quot; &gt; &lt;!-- 手机重启 --&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 添加权限：android.permission.RECEIVE_BOOT_COMPLETED 123456789101112131415161718192021222324class BootCompleteReceive extends BroadcastReceiver&#123;······ @Override public void onReceive(Context context, Intent intent) &#123; LogUtils.d(&quot;手机重启...&quot;); String newSim = PhoneUtils.getSimSerialNumber(context) + &quot;123&quot;; String sim = SharePreferenceUtils.getString(context, SharePreferenceUtils.KEY_BIND_SIM); if(newSim.equals(sim))&#123; LogUtils.d(&quot;手机sim卡没变...&quot;); return; &#125; boolean protecting = SharePreferenceUtils.getBoolean(context, SharePreferenceUtils.KEY_SAFE_PROTECTED, false); if(!protecting)&#123; return; &#125; LogUtils.d(&quot;手机丢失了，sim卡变了...&quot;); //安全号码 String number = SharePreferenceUtils.getString(context, SharePreferenceUtils.KEY_SAFE_NUMBER); //发送报警短信 SmsManager manager = SmsManager.getDefault(); //需要添加发送短信权限 manager.sendTextMessage(number, null, &quot;手机已丢失！&quot;, null, null); LogUtils.d(&quot;发送报警短信...&quot;); &#125; 14.屏蔽短信 创建新广播接收者 清单文件注册上述广播，权限android.provider.Telephony.SMS_RECEIVED 123456&lt;receiver android:name=&quot;.receiver.SmsBroadcastReceiver&quot;&gt; &lt;!-- 接收短信 --&gt; &lt;intent-filter android:priority=&quot;1000&quot;&gt; &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 注意：上述action在高版本被谷歌隐藏，真实情况该api还可以使用，为了使用可先降低版本，添加action在还原高版本 onReceive接收短信 123456789101112class SmsBroadcastReceiver extends BroadcastReceiver&#123;······· Object[] objs = intent.getExtras.get(&quot;pdus&quot;); for(Object obj : objs)&#123; SmsMessage sms = SmsMessage.createFromPdu((byte[]) obj); //String sender = sms.getOriginatingAddress();//发送者 String content = sms.getMessageBody();//短信内容 //判断内容 if(&quot;广告短信&quot;.equals(content))&#123; abortBroadcast();//屏蔽，不让用户看到该条短信 &#125;&#125; 15.手机播放音乐 存放本地的res/raw目录下 代码： 1234MediaPlayer player = MediaPlayer.create(context, R.raw.music);player.setLooping(true);//无限播放player.setVolume(1f, 1f);//设置最大声音player.start();//开始播放 16.手机定位 123451.getSystemService获取LocationManager2.manager请求位置requestLocationUpdates3.监听定位回调onLocationChanged4.退出取消定位：mLocManager.removeUpdates(mListener);5.添加GPS定位权限android.permission.ACCESS_FINE_LOCATION 17.火星座标系转真是座标 1234567891011121314151617//火星坐标系转成正式数据：收费//开源工具:不能使用在商业项目，违法try &#123; InputStream is = getAssets().open(&quot;axisoffset.dat&quot;); ModifyOffset modifyOffset = ModifyOffset.getInstance(is); PointDouble pt = new PointDouble(longitude, latitude);//火星坐标对象 PointDouble result = modifyOffset.s2c(pt);//真实坐标系，防盗谷歌地图，确认是否显示真实位置 Log.d(TAG, result.toString());&#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 18.设备管理员(源码DeviceAdminReceiver ) 使用的一般步骤 123451.新建广播接受者：继承DeviceAdminReceiver2.清单文件：注册设备管理员，和BroadcastReceiver一样，参考上面打开的文档3.设备管理员权限申请：通过一个xml文件申请（保存在res/xml目录下），具体参考文档4.使用api：DevicePolicyManager，manager.lockNow()锁屏，activity.finish();5.用户激活设备管理员：设置-安全-设备管理器-激活应用 避免手机防盗的代码 1234567891011121314151617181920212223242526272829DevicePolicyManager mDevPolicyManager = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);ComponentName mDeviceAdminSample = new ComponentName(this, ScreenLockReceiver.class);boolean iaActive = mDevPolicyManager.isAdminActive(mDeviceAdminSample);if(!iaActive)&#123;//没有激活过，激活 //开启 Intent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN); intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, mDeviceAdminSample); intent.putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION, getString(R.string.add_admin_extra_app_text)); startActivityForResult(intent, REQUEST_CODE_ENABLE_ADMIN);&#125;else&#123; lock(mDevPolicyManager);&#125;private void lock(DevicePolicyManager mDevPolicyManager) &#123; mDevPolicyManager.lockNow(); finish();&#125;@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if(requestCode == REQUEST_CODE_ENABLE_ADMIN &amp;&amp; resultCode == Activity.RESULT_OK)&#123; lock(mDevPolicyManager); &#125;else&#123; finish(); &#125;&#125;","categories":[],"tags":[]},{"title":"微信小程序","slug":"微信小程序","date":"2017-11-20T14:32:53.000Z","updated":"2017-11-20T16:30:32.072Z","comments":true,"path":"2017/11/20/微信小程序/","link":"","permalink":"http://yoursite.com/2017/11/20/微信小程序/","excerpt":"","text":"1.分辨率问题​ 以iP6的物理像素750*1334为设计稿进行设计 iPhone6下1px = 1rpx iPhone6 plus 下 1px = 0.6rpx 2.页面之间的跳转​ //会跳转并且可以返回父页面，会执行onHide生命周期 wx.navigateTo({ url:”../posts/post” }); //跳转后不可以返回父页面，会执行onUnLoad生命周期 wx.redirectTo({ url:&quot;../posts/post&quot; }) 3.点击事件​ //点击子节点，子父节点都会相应事件 开启撸猫之旅 //点击子节点，只有子节点会有相应 开启撸猫之旅 4..js文件data文件执行该过程​ 小程序总是会读取data对象来做数据绑定，是在onLoad事件执行之后发生的。 5.缓存的处理(不能超过10M)​ wx.setStorageSync(“key”,”value”) wx.getStorageSync(&quot;key&quot;) wx.removeStorageSync(&quot;key&quot;) wx.clearStorageSync(); ​​​​​​​​​​​​​​​​​​","categories":[],"tags":[]}]}